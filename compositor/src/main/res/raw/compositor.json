{
  "events": {
    // Changes to TalkBack state.
    "SpokenFeedbackOn": {
      "ttsOutput": "@string/talkback_on",
      "ttsQueueMode": "uninterruptible",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "SpokenFeedbackSuspended": {
      "ttsOutput": "@string/talkback_suspended",
      "ttsQueueMode": "uninterruptible",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "SpokenFeedbackResumed": {
      "ttsOutput": "@string/talkback_resumed",
      "ttsQueueMode": "uninterruptible",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "SpokenFeedbackDisabled": {
      "ttsOutput": "@string/talkback_disabled",
      "ttsQueueMode": "uninterruptible",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    // Changes to keyboard state.
    "CapsLockOn": {
      "ttsOutput": "@string/value_caps_lock_on",
      "ttsQueueMode": "interrupt",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "CapsLockOff": {
      "ttsOutput": "@string/value_caps_lock_off",
      "ttsQueueMode": "interrupt",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "NumLockOn": {
      "ttsOutput": "@string/value_num_lock_on",
      "ttsQueueMode": "interrupt",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "NumLockOff": {
      "ttsOutput": "@string/value_num_lock_off",
      "ttsQueueMode": "interrupt",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "ScrollLockOn": {
      "ttsOutput": "@string/value_scroll_lock_on",
      "ttsQueueMode": "interrupt",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "ScrollLockOff": {
      "ttsOutput": "@string/value_scroll_lock_off",
      "ttsQueueMode": "interrupt",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    // Changes in device orientation.
    "OrientationPortrait": {
      "ttsOutput": "@string/orientation_portrait",
      "ttsQueueMode": "uninterruptible",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "OrientationLandscape": {
      "ttsOutput": "@string/orientation_landscape",
      "ttsQueueMode": "uninterruptible",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    // These hint events deal with focus-event hints, not window-event hints.
    "Hint": {
      "ttsOutput": {
        "switch": "$event.hintType",
        "cases": {
          "access_focus": {
            "if": "$node.isAccessibilityFocused",
            "then": "%get_hint_from_node"
          },
          "input_focus": {
            "if": "$global.enableUsageHint && $node.isFocused",
            "then": "%get_input_focus_hint_from_node"
          },
          "screen": {
            "if": "$global.enableUsageHint",
            "then":"$event.hintText"
          }
        }
      },
      "refreshSourceNode": true,
      "ttsQueueMode": "queue",
      "ttsForceFeedbackAudioPlaybackActive": "$event.hintForceAudioPlaybackActive",
      "ttsForceFeedbackMicrophoneActive": "$event.hintForceMicrophoneActive",
      "ttsForceFeedbackSsbActive": false
    },
    "ScreenMagnificationChanged": {
      "ttsOutput": {
        "if": "$screenMagnification.lastScale == 1 && $screenMagnification.currentScale > 1",
        "then": "@string/template_screen_magnification_on(round($screenMagnification.currentScale * 100))",
        "else": {
          "if": "$screenMagnification.currentScale == 1 && $screenMagnification.lastScale > 1",
          "then": "@string/screen_magnification_off",
          "else": "@string/template_screen_magnification_scale_changed(round($screenMagnification.currentScale * 100))"
        }
      },
      "ttsClearQueueGroup": "screen_magnification",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "uninterruptible",
      "ttsForceFeedbackAudioPlaybackActive": false,
      "ttsForceFeedbackMicrophoneActive": false,
      "ttsForceFeedbackSsbActive": false
    },
    // Selector events
    "EVENT_SELECT_SPEECH_RATE": {
      "ttsOutput": "@string/selector_speech_rate_output",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "EVENT_SELECT_VERBOSITY": {
      "ttsOutput": "@string/selector_verbosity_output",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "EVENT_SELECT_GRANULARITY": {
      "ttsOutput": "@string/selector_granularity_output",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "EVENT_SELECT_AUDIO_FOCUS": {
      "ttsOutput": "@string/selector_audio_focus_output",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "EVENT_SPEECH_RATE_CHANGE": {
      "ttsOutput": "@string/template_speech_rate_change(round($global.speechRate * 50))",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "EVENT_AUDIO_FOCUS_SWITCH": {
      "ttsOutput": {
        "if": "$global.useAudioFocus",
        "then": "@string/audio_focus_on",
        "else": "@string/audio_focus_off"
      },
      "ttsForceFeedback": true
    },
    // Accessibility Events.
    "TYPE_VIEW_ACCESSIBILITY_FOCUSED": {
      "ttsOutput": {
        "join": [
          {
            "fallback": [
              "%get_description_for_tree",
              "%event_description"
            ]
          },
          {
            "fallback": [
              {
                "if": "#VERBOSITY_SPEAK_COLLECTION_INFO",
                "then": "%collection_item_transition"
              },
              {
                "_comment": "Don't announce heading for web container.",
                "_comment": "See  and  for details.",
                "if": "!$node.isWebContainer && $node.isHeading",
                "then": {
                  "fallback":[
                    "$node.roleDescription",
                    "@string/heading_template"
                  ]
                }
              }
            ]
          },
          {
            "if": "#VERBOSITY_SPEAK_COLLECTION_INFO",
            "then": "%collection_transition"
          },
          "%window_transition"
        ]
      },
      "ttsQueueMode": {
        "if":"$event.isInitialFocus",
        "then":"queue",
        "else":"flush"
      },
      "ttsAddToHistory": true,
      // TODO: Remove the next line when focus management feature is settled down.
      //"ttsForceFeedback": "!$global.syncedAccessibilityFocusLatch && $node.role != 'web_view'",
      "ttsForceFeedbackAudioPlaybackActive": "$event.isForcedFeedbackAudioPlaybackActive",
      "ttsForceFeedbackMicrophoneActive": "$event.isForcedFeedbackMicrophoneActive",
      "ttsForceFeedbackSsbActive": "$event.isForcedFeedbackSsbActive",
      "advanceContinuousReading": true,
      "earcon": {
        "if": "($node.windowType == 'split_screen_divider') && ($windows.lastWindowId != $node.windowId)",
        "then": "@raw/complete",
        "else": {
          "if": "$focus.isLastFocusInScrollableNode != $focus.isCurrentFocusInScrollableNode",
          "then": {
            "if": "$focus.isCurrentFocusInScrollableNode",
            "then": "@raw/chime_up",
            "else": "@raw/chime_down"
          },
          "else": {
            "if": "$node.isActionable",
            "then": "@raw/focus_actionable",
            "else": "@raw/focus"
          }
        }
      },
      "haptic": {
        "if": "$node.isActionable",
        "then": "@array/view_actionable_pattern",
        "else": "@array/view_hovered_pattern"
      },
      "preventDeviceSleep": true
    },
    "TYPE_VIEW_FOCUSED": {
      "ttsOutput": "%event_description",
      "ttsAddToHistory": true,
      // From FallbackFormatter
      // TODO: Delete porting comments.
      "earcon": {
        "if": "$event.sourceIsNull",
        "then": "@raw/focus_actionable"
      },
      "haptic": {
        "if": "$event.sourceIsNull",
        "then": "@array/view_focused_or_selected_pattern"
      }
    },
    "TYPE_VIEW_HOVER_ENTER": {
      "ttsOutput": "%event_description",
      "ttsAddToHistory": true,
      // TODO: respect user settings
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true,
      // From FallbackFormatter
      "earcon": {
        "if": "$event.sourceIsNull",
        "then": "@raw/focus"
      },
      "haptic": {
        "if": "$event.sourceIsNull",
        "then": "@array/view_hovered_pattern"
      }
    },
    "TYPE_NOTIFICATION_STATE_CHANGED": {
      // From speechstrategy.xml
      "ttsOutput": {
        "switch": "$event.sourceRole",
        "cases": {
          "toast": "%event_description"
        },
        "default": {
          "join": [
            "%event_notification_category",
            "$event.notificationDetails"
          ]
        }
      },
      "ttsQueueMode": {
        "switch": "$event.sourceRole",
        "cases": {
          "toast": "uninterruptible"
        },
        "default": "queue"
      },
      "ttsAddToHistory": true,
      "ttsForceFeedbackAudioPlaybackActive": "$event.sourceRole == 'toast'",
      "ttsForceFeedbackMicrophoneActive": "$event.sourceRole == 'toast'",
      "ttsForceFeedbackSsbActive": false,
      "ttsForceFeedbackPhoneCallActive": "$event.sourceRole == 'toast'"
    },
    "TYPE_ANNOUNCEMENT": {
      // From speechstrategy.xml
      "ttsOutput": "%event_description",
      "ttsQueueMode": "queue",
      "ttsAddToHistory": true,
      "ttsSkipDuplicate": true,
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": false,
      "haptic": "@array/notification_pattern"
    },
    "TYPE_VIEW_CLICKED": {
      "ttsOutput": {
        "fallback": [
          "%node_checked",
          "%node_descendant_checked",
          "%notify_selected",
          "%notify_collapsed_or_expanded"
        ]
      },
      "ttsQueueMode": "queue",
      "ttsAddToHistory": true,
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true,
      "ttsSkipDuplicate": true,
      "refreshSourceNode": true,
      "earcon": "@raw/tick",
      "haptic": "@array/view_clicked_pattern"
    },
    "TYPE_VIEW_LONG_CLICKED": {
      "earcon": "@raw/long_clicked",
      "haptic": "@array/view_long_clicked_pattern"
    },
    // TODO: Interpret this event in WindowEventFilter.
    "TYPE_WINDOW_STATE_CHANGED": {
      "ttsOutput": {
        "switch": "$event.sourceRole",
        "cases": {
          "drawer_layout": "@string/template_drawer_opened(%event_description)",
          "icon_menu": "@string/value_options_menu_open",
          "sliding_drawer": "@string/value_sliding_drawer_opened",
          "list": {
            // From speechstrategy.xml
            // TODO: Consider removing this case, since we do not see it occur.
            "if": "!$event.text0 && !$event.contentDescription",
            "then": "@plurals/template_containers($event.itemCount, %event_description, $event.itemCount)"
          }
        }
      },
      "ttsQueueMode": {
        "switch": "$event.sourceRole",
        "cases": {
          "icon_menu": "uninterruptible",
          "list": {
            // From speechstrategy.xml
            "if": "!$event.text0 && !$event.contentDescription",
            "then": "uninterruptible"
          }
        }
      },
      "ttsAddToHistory": true,
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "TYPE_WINDOW_CONTENT_CHANGED": {
      // From speechstrategy.xml
      "ttsOutput": {
        "if": "$node.liveRegion != 'none'",
        "then": "%get_description_for_tree",
        "else": {
          "if": "$node.isAccessibilityFocused && $event.isContentDescriptionChanged",
          "then": "$event.contentDescription",
          // When an error is displayed in an edit text, it sends
          // AccessibilityEvent#CONTENT_CHANGE_TYPE_UNDEFINED. At this point talkback should
          // indicate the presence of an error to the user. See 
          // Note that its textView that actually sets the error and sends the a11y event but
          // talkback is currently handling only edit texts. see TextView#setError().
          "else": {
            "if": "$node.role == 'edit_text' && $event.isContentUndefined",
            "then": "%get_accessibility_node_error"
          }
        }
      },
      "ttsQueueMode": {
        "if": "$node.liveRegion == 'assertive'",
        "then": "interrupt",
        "else": "queue"
      },
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": false,
      "refreshSourceNode": "$node.liveRegion != 'none'",
      "ttsAddToHistory": true,
      "ttsSkipDuplicate": true
    },
    "TYPE_VIEW_SELECTED": {
      "ttsOutput": {
        "switch": "$node.role",
        "cases": {
          "seek_control": "%rule_seek_bar",
          "progress_bar": {
            "if": "$event.sourceIsNull || $node.isFocused || $node.isAccessibilityFocused || $node.liveRegion != 'none'",
            "then": {
              "if": "length($event.text) > 0 && %event_description != $node.text",
              "then": "%event_description",
              "else": "%get_seek_bar_state"
            }
          }
        },
        "default": "%event_description"
        // From speechstrategy.xml
      },
      "ttsAddToHistory": true,
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": false,
      "earcon": {
        "switch": "$node.role",
        "cases": {
          "seek_control": "",
          // From RuleSeekBar
          "progress_bar": {
            // From ProgressBarFormatter
            "if": "$event.sourceIsNull || $node.isFocused || $node.isAccessibilityFocused || $node.liveRegion != 'none'",
            "then": {
              "if": "length($event.text) > 0 && %event_description != $node.text",
              "then": "",
              "else": "@raw/scroll_tone"
            }
          }
        },
        "default": {
          // From speechstrategy.xml
          "if": "!%event_description",
          "then": "@raw/focus_actionable"
        }
      },
      "earcon_rate": {
        "if": "$node.role == 'progress_bar'",
        "then": "2.0 ^ ($event.progressPercent / 50.0 - 1)"
      },
      "earcon_volume": {
        "if": "$node.role == 'progress_bar'",
        "then": "0.5"
      },
      "haptic": {
        "switch": "$node.role",
        "cases": {
          "seek_control": "",
          // From RuleSeekBar
          "progress_bar": ""
          // From ProgressBarFormatter
        },
        "default": {
          // From speechstrategy.xml
          "if": "!%event_description",
          "then": "@array/view_focused_or_selected_pattern"
        }
      },
      "ttsQueueMode": {
        "switch": "$event.sourceRole",
        "cases": {
          "progress_bar": {
            "if": "$node.liveRegion == 'assertive'",
            "then": "interrupt",
            "else": "uninterruptible"
          },
          "action_bar_tab": "uninterruptible",
          // From speechstrategy.xml
          "tab_bar": "uninterruptible",
          // From speechstrategy.xml
          "seek_control": "uninterruptible"
          // From RuleSeekBar
        }
      },
      "ttsClearQueueGroup": {
        "switch": "$node.role",
        "cases": {
          "progress_bar": "progress_bar",
          "seek_control": "seek_progress"
        }
      },
      "ttsSkipDuplicate": "$node.role == 'progress_bar' || $node.role == 'seek_control'"
    },
    "TYPE_VIEW_SCROLLED": {
      "earcon": "@raw/scroll_tone",
      "earcon_rate": "2.0 ^ ($event.scrollPercent / 50.0 - 1)"
    },
    "EVENT_SCROLL_POSITION": {
      "ttsOutput": {
        "if": "$node.isVisible && $event.fromIndex >= 0 && $event.itemCount > 0",
        "then": {
          "if": "$node.role == 'pager'",
          "then": {
            "if": "$node.selectedPageTitle",
            "then": {
              "join": [
                "$node.selectedPageTitle",
                "@string/template_viewpager_index_count_short($event.fromIndex + 1, $event.itemCount)"
              ]
            },
            "else": "@string/template_viewpager_index_count($event.fromIndex + 1, $event.itemCount)"
          },
          "else": {
            "if": "$event.fromIndex == $event.toIndex || $event.toIndex < 0 || ($event.toIndex + 1) > $event.itemCount",
            "then": "@string/template_scroll_from_count($event.fromIndex + 1, $event.itemCount)",
            "else": "@string/template_scroll_from_to_count($event.fromIndex + 1, $event.toIndex + 1, $event.itemCount)"
          }
        }
      },
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": false,
      "refreshSourceNode": true,
      "ttsQueueMode": "queue",
      "ttsPitch": 1.2
    },
    "EVENT_TYPE_INPUT_TEXT_CLEAR": {
      "ttsOutput": {
        "join": [
          {
            "if": "$event.isCut",
            "then": {
              "join": [
                "@string/template_text_cut($event.beforeText)",
                "@string/value_text_cleared"
              ]
            },
            "else": "@string/value_text_cleared"
          },
          "%notify_error"
        ]
      },
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": false
    },
    "EVENT_TYPE_INPUT_TEXT_REMOVE": {
      "ttsOutput": {
        "join": [
          {
            "if": "$event.isCut",
            "then": "@string/template_text_cut($event.removedText)",
            "else": "@string/template_text_removed($event.removedText)"
          },
          "%notify_error"
        ]
      },
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsPitch": 1.2,
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "EVENT_TYPE_INPUT_TEXT_ADD": {
      "ttsOutput": {
        "join": [
          {
            "fallback": [
              "$event.initialWord",
              {
                "if": "$event.isPaste",
                "then": "@string/template_text_pasted($event.addedText)",
                "else": "$event.addedText"
              }
            ]
          },
          "%notify_max_length_reached",
          "%notify_error"
        ]
      },
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "EVENT_TYPE_INPUT_TEXT_REPLACE": {
      "ttsOutput": {
        "join": [
          "@string/template_text_replaced($event.addedText, $event.removedText)",
          {
            "if": "!$event.isPaste",
            "then": "spelling($event.addedText)"
          },
          "%notify_max_length_reached",
          "%notify_error"
        ]
      },
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsPitch": 1.2,
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "EVENT_TYPE_INPUT_TEXT_PASSWORD_ADD": {
      "ttsOutput": {
        "join": [
          "@string/symbol_bullet",
          "%notify_max_length_reached",
          "%notify_error"
        ]
      },
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "EVENT_TYPE_INPUT_TEXT_PASSWORD_REMOVE": {
      "ttsOutput": {
        "join": [
          "@string/template_text_removed(@string/symbol_bullet)",
          "%notify_error"
        ]
      },
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsPitch": 1.2,
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "EVENT_TYPE_INPUT_TEXT_PASSWORD_REPLACE": {
      "ttsOutput": {
        "join": [
          "@string/template_replaced_characters($event.removedCount, $event.addedCount)",
          "%notify_max_length_reached",
          "%notify_error"
        ]
      },
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsPitch": 1.2,
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "EVENT_TYPE_INPUT_SELECTION_MOVE_CURSOR_NO_SELECTION": {
      "ttsOutput": {
        "join": [
          "$event.traversedText",
          {
            "if": "$event.toIndex == 0",
            "then": "@string/notification_type_beginning_of_field",
            "else": {
              "if": "$event.toIndex == $event.itemCount",
              "then": "@string/notification_type_end_of_field"
            }
          }
        ]
      },
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "EVENT_TYPE_INPUT_SELECTION_MOVE_CURSOR_WITH_SELECTION": {
      "ttsOutput": {
        "join": [
          {
            "if": "$event.deselectedText",
            "then": "@string/template_text_unselected($event.deselectedText)"
          },
          {
            "if": "$event.selectedText",
            "then": "@string/template_text_selected($event.selectedText)"
          }
        ]
      },
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "EVENT_TYPE_INPUT_SELECTION_MOVE_CURSOR_SELECTION_CLEARED": {
      "ttsOutput": {
        "join": [
          "@string/notification_type_selection_cleared",
          {
            "if": "$event.toIndex == 0",
            "then": "@string/notification_type_beginning_of_field",
            "else": {
              "if": "$event.toIndex == $event.itemCount",
              "then": "@string/notification_type_end_of_field"
            }
          }
        ]
      },
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    "EVENT_TYPE_INPUT_SELECTION_TEXT_TRAVERSAL": {
      // TODO: Make this the same as EVENT_TYPE_INPUT_SELECTION_MOVE_CURSOR_NO_SELECTION ?
      "ttsOutput": "$event.traversedText",
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsForceFeedback": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "advanceContinuousReading": true,
      "ttsForceFeedbackSsbActive": true
    },
    "EVENT_TYPE_INPUT_SELECTION_SELECT_ALL_WITH_KEYBOARD": {
      "ttsOutput": "@string/template_announce_selected_text($event.textOrDescription)",
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsForceFeedbackAudioPlaybackActive": true,
      "ttsForceFeedbackMicrophoneActive": true,
      "ttsForceFeedbackSsbActive": true
    },
    // Text events with no speech feedback
    "EVENT_TYPE_INPUT_CHANGE_INVALID": {},
    "EVENT_TYPE_INPUT_SELECTION_FOCUS_EDIT_TEXT": {},
    "EVENT_TYPE_INPUT_SELECTION_MOVE_CURSOR_TO_BEGINNING": {},
    // Feedback handled by menurules.
    "EVENT_TYPE_INPUT_SELECTION_MOVE_CURSOR_TO_END": {},
    "EVENT_TYPE_INPUT_SELECTION_CUT": {},
    // Feedback handled by EVENT_TYPE_INPUT_TEXT_ADD/REMOVE
    "EVENT_TYPE_INPUT_SELECTION_PASTE": {},
    "EVENT_TYPE_INPUT_SELECTION_RESET_SELECTION": {},
    "EVENT_TYPE_INPUT_SELECTION_SELECT_ALL": {}
    // Feedback handled by menurules.RuleEditText
  },
  "named_nodes": {
    // Events
    "event_description": {
      "fallback": [
        "$event.contentDescription",
        "%event_aggregate_text"
      ]
    },
    "event_notification_category": {
      "switch": "$event.notificationCategory",
      "cases": {
        "call": "@string/notification_category_call",
        "msg": "@string/notification_category_msg",
        "email": "@string/notification_category_email",
        "event": "@string/notification_category_event",
        "promo": "@string/notification_category_promo",
        "alarm": "@string/notification_category_alarm",
        "progress": "@string/notification_category_progress",
        "social": "@string/notification_category_social",
        "err": "@string/notification_category_err",
        "transport": "@string/notification_category_transport",
        "sys": "@string/notification_category_sys",
        "service": "@string/notification_category_service"
      }
    },
    "event_aggregate_text": {
      "join": "$event.text"
    },
    "notify_error": {
      // TextFormatters.ChangedTextFormatter.notifyError()
      "if": "$event.sourceError",
      "then": "@string/template_text_error($event.sourceError)"
    },
    "notify_max_length_reached": {
      // TextFormatters.ChangedTextFormatter.notifyMaxLengthReached()
      "if": "$event.sourceMaxTextLength > -1 && length($event.text0) >= $event.sourceMaxTextLength",
      "then": "@string/value_text_max_length"
    },
    // Collections
    "collection_item_transition": {
      "if": "$collection.isRowTransition || $collection.isColumnTransition",
      "then": {
        "switch": "$collection.role",
        "cases": {
          "grid": {
            "join": [
              {
                "if": "!$node.roleDescription",
                "then": {
                  "switch": "$collection.tableItem.headingType",
                  "cases": {
                    "column": "@string/column_heading_template",
                    "row": "@string/row_heading_template,",
                    "indeterminate": "@string/heading_template"
                  }
                }
              },
              {
                "if": "$collection.isRowTransition && $collection.tableItem.rowIndex != -1 && $collection.tableItem.headingType != 'row'",
                "then": {
                  "fallback": [
                    "$collection.tableItem.rowName",
                    "@string/row_index_template($collection.tableItem.rowIndex + 1)"
                  ]
                }
              },
              {
                "if": "$collection.isColumnTransition && $collection.tableItem.columnIndex != -1 && $collection.tableItem.headingType != 'column'",
                "then": {
                  "fallback": [
                    "$collection.tableItem.columnName",
                    "@string/column_index_template($collection.tableItem.columnIndex + 1)"
                  ]
                }
              }
            ]
          }
        },
        "default": {
          "if": "$collection.listItem.isHeading && !$node.roleDescription",
          "then": "@string/heading_template"
        }
      }
    },
    "collection_transition": {
      "switch": "$collection.transition",
      "cases": {
        "none": "",
        "enter": {
          "switch": "$collection.role",
          "cases": {
            "list": {
              "join": [
                {
                  "if": "$collection.name",
                  "then": "@string/in_list($collection.name)",
                  "else": "@string/in_list_without_name"
                },
                "%collection_level",
                "%collection_list_item_count"
              ]
            },
            "grid": {
              "join": [
                {
                  "if": "$collection.name",
                  "then": "@string/in_grid($collection.name)",
                  "else": "@string/in_grid_without_name"
                },
                "%collection_level",
                "%collection_grid_item_count"
              ]
            },
            "pager": {
              // A pager with a CollectionInfo with 0 or 1 elements will never get to this point
              // because CollectionState#shouldEnter returns false beforehand. This case handles a
              // ViewPager1 which doesn't have a CollectionInfo (rowCount and columnCount do not
              // exist and are set to -1) but CollectionState#shouldEnter returns true because it
              // has >2 children. It may or may not have a name.
              "if": "$collection.rowCount == -1 && $collection.columnCount == -1",
              "then": {
                "if": "$collection.name",
                "then": "@string/in_pager_with_name($collection.name)",
                "else": "@string/in_pager"
              },
              "else": {
                "if": "$collection.rowCount > 1 && $collection.columnCount > 1",
                "then": "%collection_grid_pager",
                "else": {
                  "if": "$collection.isVerticalAligned",
                  "then": "%collection_vertical_pager",
                  "else": "%collection_horizontal_pager"
                }
              }
            }
          }
        },
        "exit": {
          "if": "$collection.exists",
          "then": {
            "switch": "$collection.role",
            "cases": {
              "list": {
                "if": "$collection.name",
                "then": "@string/out_of_list($collection.name)",
                "else": "@string/out_of_list_without_name"
              },
              "grid": {
                "if": "$collection.name",
                "then": "@string/out_of_grid($collection.name)",
                "else": "@string/out_of_grid_without_name"
              },
              "pager": {
                "if": "$collection.rowCount == -1 && $collection.columnCount == -1",
                "then": {
                  "if": "$collection.name",
                  "then": "@string/out_of_pager_with_name($collection.name)",
                  "else": "@string/out_of_pager"
                },
                "else": {
                  "if": "$collection.rowCount > 1 && $collection.columnCount > 1",
                  "then": {
                    "if": "$collection.name",
                    "then": "@string/out_of_grid_pager_with_name($collection.name)",
                    "else": "@string/out_of_grid_pager"
                  },
                  "else": {
                    "if": "$collection.isVerticalAligned",
                    "then": {
                      "if": "$collection.name",
                      "then": "@string/out_of_vertical_pager_with_name($collection.name)",
                      "else": "@string/out_of_vertical_pager"
                    },
                    "else": {
                      "if": "$collection.name",
                      "then": "@string/out_of_horizontal_pager_with_name($collection.name)",
                      "else": "@string/out_of_horizontal_pager"
                    }
                  }
                }
              }
            }
          }
        },
        "interior": ""
      }
    },
    "collection_level": {
      "if": "$collection.level >= 0",
      "then": "@string/template_collection_level($collection.level + 1)"
    },
    "collection_list_item_count": {
      "if": "$collection.rowCount >= 0 && $collection.columnCount >= 0",
      "then": {
        "if": "$collection.isVerticalAligned && $collection.rowCount >= 0",
        "then": "@plurals/template_list_total_count($collection.rowCount, $collection.rowCount)",
        "else": {
          "if": "$collection.isHorizontalAligned && $collection.columnCount >= 0",
          "then": "@plurals/template_list_total_count($collection.columnCount, $collection.columnCount)"
        }
      }
    },
    "collection_grid_item_count": {
      "if": "$collection.rowCount >= 0 && $collection.columnCount >= 0",
      "then": "@plurals/template_list_row_count($collection.rowCount, $collection.rowCount), @plurals/template_list_column_count($collection.columnCount, $collection.columnCount)"
    },
    "collection_grid_pager": {
      "join": [
        {
          "if": "$collection.name",
          "then": "@string/in_grid_pager_with_name($collection.name)",
          "else": "@string/in_grid_pager"
        },
        "%collection_level",
        "@string/row_index_template($collection.pagerItem.rowIndex + 1), @string/column_index_template($collection.pagerItem.columnIndex + 1)",
        "@plurals/template_list_row_count($collection.rowCount, $collection.rowCount), @plurals/template_list_column_count($collection.columnCount, $collection.columnCount)"
      ]
    },
    "collection_vertical_pager": {
      "join": [
        {
          "if": "$collection.name",
          "then": "@string/in_vertical_pager_with_name($collection.name)",
          "else": "@string/in_vertical_pager"
        },
        "%collection_level",
        "@string/template_viewpager_index_count($collection.pagerItem.rowIndex + 1, $collection.rowCount)"
      ]
    },
    "collection_horizontal_pager": {
      "join": [
        {
          "if": "$collection.name",
          "then": "@string/in_horizontal_pager_with_name($collection.name)",
          "else": "@string/in_horizontal_pager"
        },
        "%collection_level",
        "@string/template_viewpager_index_count($collection.pagerItem.columnIndex + 1, $collection.columnCount)"
      ]
    },
    // Windows
    "window_transition": {
      "if": "$node.windowId != $windows.lastWindowId",
      "then": {
        "if": "$node.windowType == 'picture_in_picture'",
        "then": "@string/template_overlay_window(getWindowTitle($node.windowId))",
        "else": {
          "if": "($windows.isSplitScreenMode || $global.inputMode == 'keyboard') && ($node.windowType == 'application' || $node.windowType == 'system')",
          "then": "getWindowTitle($node.windowId)"
        }
      }
    },
    // Nodes
    // From NodeSpeechRuleProcessor.getDescriptionForTree()
    "get_description_for_tree": {
      "switch": "#VERBOSITY_DESCRIPTION_ORDER",
      "cases": {
        "StateNameRolePosition": {
          "join": [
            "%notify_selected",
            "%tree_description_with_label",
            "%notify_disabled"
            // Announcement of "disabled" should always be a postfix.
          ]
        },
        "RoleNameStatePosition": {
          "join": [
            "%tree_description_with_label",
            "%notify_selected",
            "%notify_disabled"
          ]
        },
        "NameRoleStatePosition": {
          "join": [
            "%tree_description_with_label",
            "%notify_selected",
            "%notify_disabled"
          ]
        }
      }
    },
    // From NodeSpeechRuleProcessor.formatTextWithLabel()
    "tree_description_with_label": {
      "if": "length(%label_description) > 0",
      "then": "@string/template_labeled_item(%append_description_for_tree, %label_description)",
      "else": "%append_description_for_tree"
    },
    "notify_disabled": {
      "if": "($node.hasNativeWebContent || $node.isActionable) && !$node.isEnabled",
      "then": "@string/value_disabled"
    },
    "notify_selected": {
      "if": "$node.isSelected",
      "then": "@string/value_selected"
    },
    "notify_collapsed_or_expanded": {
      "if": "$node.isExpandable",
      "then": "@string/value_collapsed",
      "else":{
        "if": "$node.isCollapsible",
        "then": "@string/value_expanded"
      }
    },

    // From NodeSpeechRuleProcessor.formatTextWithLabel()
    "label_description": {
      "for_reference": "$node.labeledBy",
      "evaluate": "%append_description_for_tree"
    },
    // From NodeSpeechRuleProccessor.appendDescriptionForTree()
    "append_description_for_tree": {
      "join": [
        {
          "switch": "#VERBOSITY_DESCRIPTION_ORDER",
          "cases": {
            "StateNameRolePosition": "conditionalPrepend(%description_for_tree_status, %description_for_tree_nodes)",
            "RoleNameStatePosition": "conditionalAppend(%description_for_tree_nodes, %description_for_tree_status)",
            "NameRoleStatePosition": "conditionalAppend(%description_for_tree_nodes, %description_for_tree_status)"
          }
        },
        // Since error message is more valuable than a hint, its placed before the hint.
        // See 
        "%get_accessibility_node_error",
        // TODO: Currently we have appended the accessibility hint just after the node details that talkback announces.
        // In future we can append $node.hint for a node similar to name, state and type and take hint into consideration for deciding VERBOSITY_DESCRIPTION_ORDER.
        // These hints are only present for edit_texts and web view at present.
        "%get_accessibility_node_hint",
        "%tooltip_text_deduplicated"
      ]
    },
    "description_for_tree_status": {
      "join": [
        // From NodeSpeechRuleProcessor.appendExpandedOrCollapsedStatus()
        "%notify_collapsed_or_expanded",
        // From NodeSpeechRuleProcessor.appendCheckedStatus()
        {
          "if": "$node.isCheckable && $node.role != 'switch' && $node.role != 'toggle_button' && ($node.role != 'checked_text_view' || $node.isChecked)",
          "then": {
            "if": "$node.isChecked",
            "then": "@string/value_checked",
            "else": "@string/value_not_checked"
          }
        }
      ]
    },
    "description_for_tree_nodes": {
      "join": [
        "%get_description_for_node",
        {
          "if": "($node.role == 'grid' || $node.role == 'list' || $node.role == 'pager' || !$node.contentDescription) && $node.role != 'web_view'",
          "then": {
            // Recurse on all visible & un-focusable children, ascending.
            "join": [
              {
                "for_each_child": "$node.childrenAscending",
                "evaluate": {
                  "if": "$node.isVisible && (!$node.isAccessibilityFocusable || ($event.isWindowContentChanged && $event.sourceIsLiveRegion))",
                  "then": "%append_description_for_tree"
                }
              }
            ]
          }
        }
      ]
    },
    // From NodeSpeechRuleProcessor.getDescriptionForNode()
    "get_description_for_node": {
      "switch": "$node.role",
      "cases": {
        "drop_down_list": "%rule_default",
        //RuleSimpleHintTemplate. Falls down to RuleDefault.
        "switch": "%rule_switch",
        "toggle_button": "%rule_switch",
        "image": "%rule_non_text_views",
        "image_button": "%rule_non_text_views",
        "edit_text": "%rule_edit_text",
        "seek_control": "%rule_seek_bar",
        "pager": "%rule_default"
        // RulePager. Falls down to RuleDefault
      },
      "default": {
        // From RulePagerPage
        "if": {
          "for_reference": "$node.parent",
          "evaluate": "$node.role == 'pager' && $node.visibleChildCount == 1"
        },
        "then": "%rule_pager_page",
        "else": {
          // From RuleViewGroup
          "if": "$node.role == 'view_group'",
          "then": "%rule_view_group",
          "else": "%rule_default"
          // From NodeSpeechRuleProcessor
        }
      }
    },
    "get_node_text": {
      // AccessibilityNodeInfoUtils.getNodeText()
      "fallback": [
        {
          // If focusing on-screen keyboard key... apply speak-passwords policy to hide key name.
          "if": "$global.lastTextEditIsPassword && !$global.speakPasswordsServicePolicy && ($event.sourceIsKeyboard || $node.isPinKey)",
          "then": "@string/symbol_bullet",
          "else": "$node.contentDescription"
        },
        "$node.text"
      ]
    },
    "get_role_description_or_default": {
      "fallback": [
        "$node.roleDescription",
        "%node_role"
      ]
    },
    "node_role": {
      "switch": "$node.role",
      "cases": {
        "button": "@string/value_button",
        "check_box": "@string/value_checkbox",
        "drop_down_list": "@string/value_spinner",
        "edit_text": "@string/value_edit_box",
        "grid": "@string/value_gridview",
        "image": "@string/value_image",
        "image_button": "@string/value_button",
        // Same as |button|
        "list": "@string/value_listview",
        "pager": "@string/value_pager",
        "progress_bar": "@string/value_progress_bar",
        "radio_button": "@string/value_radio_button",
        "seek_control": "@string/value_seek_bar",
        "switch": "@string/value_switch",
        "tab_bar": "@string/value_tabwidget",
        "toggle_button": "@string/value_switch",
        // Same as |switch|
        "view_group": "",
        // None
        "web_view": "@string/value_webview",
        "checked_text_view": ""
        // None
      }
    },
    "node_text_and_role": {
      "join": [
        "%get_node_text",
        "%get_role_description_or_default"
      ]
    },
    "role_and_node_text": {
      "join": [
        "%get_role_description_or_default",
        "%get_node_text"
      ]
    },
    "node_descendant_checked": {
      // Either node is checkable, or recurse on descendants.
      "fallback": [
        "%node_checked",
        {
          "join": [
            {
              "for_each_child": "$node.children",
              "evaluate": "%node_descendant_checked"
            }
          ]
        }
      ]
    },
    "node_checked": {
      // If node is checkable, speak checked state depending on node type.
      "if": "$node.isCheckable",
      "then": {
        "switch": "$node.role",
        "cases": {
          "switch": {
            "if": "$node.isChecked",
            "then": "@string/value_on",
            "else": "@string/value_off"
          },
          "toggle_button": {
            "if": "$node.isChecked",
            "then": "@string/value_on",
            "else": "@string/value_off"
          }
        },
        "default": {
          "if": "$node.isChecked",
          "then": "@string/value_checked",
          "else": "@string/value_not_checked"
        }
      }
    },
    "node_text_or_event_aggregate_text": {
      "fallback": [
        "$node.text",
        "%event_aggregate_text"
      ]
    },
    "node_text_or_label": {
      "fallback": [
        "%get_node_text",
        "$node.labelText",
        {
          "if": "#VERBOSITY_SPEAK_ELEMENT_IDS",
          "then": "$node.viewIdText"
        }
      ]
    },
    // SpeechRules
    "rule_default": {
      "if": "!#VERBOSITY_SPEAK_ROLE",
      "then": "%get_node_text",
      "else": {
        "switch": "#VERBOSITY_DESCRIPTION_ORDER",
        "cases": {
          "RoleNameStatePosition": "%role_and_node_text",
          "StateNameRolePosition": "%node_text_and_role",
          "NameRoleStatePosition": "%node_text_and_role"
        }
      }
    },
    "rule_edit_text": {
      "switch": "#VERBOSITY_DESCRIPTION_ORDER",
      "cases": {
        "RoleNameStatePosition": {
          "join": [
            {
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_role_description_or_default"
            },
            "%get_edit_text_text",
            "%get_edit_text_state"
          ]
        },
        "StateNameRolePosition": {
          "join": [
            "%get_edit_text_state",
            "%get_edit_text_text",
            {
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_role_description_or_default"
            }
          ]
        },
        "NameRoleStatePosition": {
          "join": [
            "%get_edit_text_text",
            {
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_role_description_or_default"
            },
            "%get_edit_text_state"
          ]
        }
      }
    },
    "rule_pager_page": {
      "if": "!#VERBOSITY_SPEAK_ROLE",
      "then": "%get_node_text",
      "else": {
        "switch": "#VERBOSITY_DESCRIPTION_ORDER",
        "cases": {
          "RoleNameStatePosition": {
            "join": [
              "%get_pager_page_role_description",
              "%get_node_text"
            ]
          },
          "StateNameRolePosition": {
            "join": [
              "%get_node_text",
              "%get_pager_page_role_description"
            ]
          },
          "NameRoleStatePosition": {
            "join": [
              "%get_node_text",
              "%get_pager_page_role_description"
            ]
          }
        }
      }
    },
    "rule_switch": {
      "switch": "#VERBOSITY_DESCRIPTION_ORDER",
      "cases": {
        "RoleNameStatePosition": {
          "join": [
            {
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_role_description_or_default"
            },
            "$node.contentDescription",
            // Name
            "%get_switch_state"
          ]
        },
        "StateNameRolePosition": {
          "join": [
            "%get_switch_state",
            "$node.contentDescription",
            // Name
            {
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_role_description_or_default"
            }
          ]
        },
        "NameRoleStatePosition": {
          "join": [
            "$node.contentDescription",
            // Name
            {
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_role_description_or_default"
            },
            "%get_switch_state"
          ]
        }
      }
    },
    "rule_seek_bar": {
      // TODO: Investigate if we should announce role description for TYPE_VIEW_SELECTED event.
      "if": "$node.isAccessibilityFocused",
      "then": {
        "switch": "#VERBOSITY_DESCRIPTION_ORDER",
        "cases": {
          "RoleNameStatePosition": {
            "join": [
              {
                "if": "#VERBOSITY_SPEAK_ROLE",
                "then": "%get_role_description_or_default"
              },
              "%get_node_text",
              "%get_seek_bar_state"
            ]
          },
          "StateNameRolePosition": {
            "join": [
              "%get_seek_bar_state",
              "%get_node_text",
              {
                "if": "#VERBOSITY_SPEAK_ROLE",
                "then": "%get_role_description_or_default"
              }
            ]
          },
          "NameRoleStatePosition": {
            "join": [
              "%get_node_text",
              {
                "if": "#VERBOSITY_SPEAK_ROLE",
                "then": "%get_role_description_or_default"
              },
              "%get_seek_bar_state"
            ]
          }
        }
      }
    },
    "rule_non_text_views": {
      "switch": "#VERBOSITY_DESCRIPTION_ORDER",
      "cases": {
        "RoleNameStatePosition": {
          "join": [
            {
              // Role
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_non_text_view_role"
            },
            "%node_text_or_label",
            // Name
            {
              // State
              "if": "!%node_text_or_label",
              "then": "@string/value_unlabelled"
            }
          ]
        },
        "StateNameRolePosition": {
          "join": [
            {
              // State
              "if": "!%node_text_or_label",
              "then": "@string/value_unlabelled"
            },
            "%node_text_or_label",
            // Name
            {
              // Role
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_non_text_view_role"
            }
          ]
        },
        "NameRoleStatePosition": {
          "join": [
            "%node_text_or_label",
            // Name
            {
              // ROle
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_non_text_view_role"
            },
            {
              // State
              "if": "!%node_text_or_label",
              "then": "@string/value_unlabelled"
            }
          ]
        }
      }
    },
    "rule_view_group": "%get_node_text",
    // Utils for speech rules.
    "get_edit_text_state": {
      "join": [
        {
          "if": "$node.isFocused && $global.isKeyboardActive",
          // isCurrentlyEditing
          "then": "@string/value_edit_box_editing"
        },
        {
          "if": "$global.isSelectionModeActive",
          "then": "@string/notification_type_selection_mode_on"
        }
      ]
    },
    "get_edit_text_text": {
      "if": "$node.isPassword && !$global.speakPasswordFieldContent",
      "then": {
        // Treat as hidden-password input field.
        "join": [
          {
            // Input type
            "fallback": [
              "$node.contentDescription",
              "@string/value_password"
            ]
          },
          {
            // Input content
            "if": "$node.text",
            "then": {
              "if": "$node.supportsActionSetSelection",
              "then": "@plurals/template_password_character_count(length($node.text), length($node.text))",
              "else": "$node.text"
            }
          }
        ]
      },
      "else": {
        // Treat as normal text input field.
        "fallback": [
          "$node.text",
          "$node.contentDescription"
        ]
      }
    },
    "get_pager_page_role_description": {
      "fallback": [
        "$node.roleDescription",
        "@string/value_pager_page"
      ]
    },
    "get_seek_bar_state": {
      "switch": "$node.rangeInfoType",
      "cases": {
        "percent": "@string/template_percent(round($node.rangeCurrentValue))",
        "undefined": {
          "if": "$event.itemCount > 0",
          "then": "@string/template_percent(round($event.progressPercent))"
        }
      },
      "default": "@string/template_percent(round($node.progressPercent))"
    },
    "get_non_text_view_role": {
      "fallback": [
        "$node.roleDescription",
        {
          "if": "!($node.role == 'image' && $node.supportsActionSelect)",
          "then": "%node_role"
        }
      ]
    },
    "get_switch_state": {
      "join": [
        "%node_text_or_event_aggregate_text",
        // Text of switch widget is "on"/"off" state.
        {
          // Complementary state for toggle button and when there is no state information from text.
          "if": "$node.role == 'toggle_button' || !%node_text_or_event_aggregate_text",
          "then": {
            "if": "$node.isChecked",
            "then": "@string/value_checked",
            "else": "@string/value_not_checked"
          }
        }
      ]
    },
    // HintRules

    // ProcessorAccessibilityHints.getHintFromNode()
    "get_hint_from_node": {
      "if": "$node.isEnabled",
      "then": {
        "if": "!$global.enableUsageHint",
        "then": "%get_hint_for_node_actions_low_verbosity",
        "else": {
          "join": [
            {
              "switch": "$node.role",
              "cases": {
                "drop_down_list": "%hint_rule_drop_down_list",
                "edit_text": "%hint_rule_edit_text",
                "seek_control": "%hint_rule_seek_bar"
              },
              "default": "%hint_rule_default"
            },
            "%get_hint_for_node_actions_high_verbosity"
          ]
        }
      }
    },
    // Hint when focusing password-input field: use headphones to hear password.
    "get_input_focus_hint_from_node": {
      "if": "$node.isEnabled",
      "then": {
        "switch": "$node.role",
        "cases": {
          "edit_text": {
            "if": "$node.isPassword && !$global.speakPasswordsServicePolicy",
            "then": "@string/summaryOff_pref_speak_passwords_without_headphones"
          }
        }
      }
    },
    "get_accessibility_node_hint": {
      // append hint to edit_text only if the edit_text is not already showing the hint as its text (when the edit_text is blank).
      "if": "$node.role != 'edit_text' || !$node.isShowingHint",
      "then": "$node.hint"
    },
    "tooltip_text_deduplicated": {
      // Using equality check because we might want to use unaltered node.tooltipText elsewhere.
      "if": "$node.tooltipText && !equals($node.tooltipText, %get_node_text)",
      "then": "$node.tooltipText"
    },
    "get_accessibility_node_error": {
      // append error message if the edit text is showing it.
      "if": "$node.role == 'edit_text' && $node.isContentInvalid",
      "then" : {
        "if": "$node.error",
        "then": "@string/template_node_error_with_error_message($node.error)"
      }
    },
    // Instance of RuleSimpleHintTemplate
    "hint_rule_drop_down_list": {
      // get_custom_hint_for_click
      "if": "$global.inputMode == 'keyboard' && $keyCombo.hasKeyForClick",
      "then": "@string/template_hint_spinner_keyboard($keyCombo.stringRepresentationForClick)",
      "else": {
        "if": "$global.inputMode == 'non_alphabetic_keyboard'",
        "then": "@string/template_hint_spinner(@string/value_press_select)",
        "else": {
          "if": "$node.role != 'text_entry_key'",
          "then": {
            "if": "$global.useSingleTap",
            "then": "@string/template_hint_spinner(@string/value_single_tap)",
            "else": "@string/template_hint_spinner(@string/value_double_tap)"
          }
        }
      }
    },
    "hint_rule_edit_text": {
      "join": [
        {
          "if": "!$node.isFocused",
          "then": {
            // get_custom_hint_for_click
            "if": "$global.inputMode == 'keyboard' && $keyCombo.hasKeyForClick",
            "then": "@string/template_hint_edit_text_keyboard($keyCombo.stringRepresentationForClick)",
            "else": {
              "if": "$global.inputMode == 'non_alphabetic_keyboard'",
              "then": "@string/template_hint_edit_text(@string/value_press_select)",
              "else": {
                "if": "$node.role != 'text_entry_key'",
                "then": {
                  "if": "$global.useSingleTap",
                  "then": "@string/template_hint_edit_text(@string/value_single_tap)",
                  "else": "@string/template_hint_edit_text(@string/value_double_tap)"
                }
              }
            }
          }
        },
        "%get_hint_for_long_click"
      ]
    },
    "hint_rule_seek_bar": {
      "if": "$node.supportsActionScrollForward || $node.supportsActionScrollBackward",
      "then": "@string/template_hint_seek_control",
      "else": "%hint_rule_default"
    },
    "hint_rule_default": {
      "join": [
        "%get_hint_for_click",
        "%get_hint_for_long_click"
      ]
    },
    // Utils.
    "get_hint_for_node_actions_low_verbosity": {
      "if": "$node.selfMenuActionAvailable",
      "then": "@string/template_hint_menu_type_low_verbosity($node.selfMenuActions)"
    },
    "get_hint_for_node_actions_high_verbosity": {
      "if": "$node.selfMenuActionAvailable",
      "then": "@string/template_hint_menu_type_high_verbosity($node.selfMenuActions, $gesture.nodeMenuShortcut)"
    },
    "get_hint_for_long_click": {
      "fallback": [
        {
          "for_reference": "$node.actionLongClick",
          "evaluate": {
            "if": "$action.label",
            "then": {
              "if": "$global.inputMode == 'keyboard' && $keyCombo.hasKeyForLongClick",
              "then": "@string/template_custom_hint_for_actions_keyboard($keyCombo.stringRepresentationForLongClick, $action.label)",
              "else": {
                "if": "$global.inputMode == 'non_alphabetic_keyboard'",
                "then": "@string/template_custom_hint_for_long_clickable_actions(@string/value_press_select, $action.label)",
                "else": {
                  "if": "$node.role != 'text_entry_key'",
                  "then": {
                    "if": "$global.useSingleTap",
                    "then": "@string/template_custom_hint_for_long_clickable_actions(@string/value_single_tap, $action.label)",
                    "else": "@string/template_custom_hint_for_long_clickable_actions(@string/value_double_tap, $action.label)"
                  }
                }
              }
            }
          }
        },
        {
          "if": "$node.isLongClickable",
          "then": {
            "if": "$global.inputMode == 'keyboard' && $keyCombo.hasKeyForLongClick",
            "then": "@string/template_hint_long_clickable_keyboard($keyCombo.stringRepresentationForLongClick)",
            "else": {
              "if": "$global.inputMode == 'non_alphabetic_keyboard'",
              "then": "@string/template_hint_long_clickable(@string/value_press_select)",
              "else": {
                "if": "$node.role != 'text_entry_key'",
                "then": {
                  "if": "$global.useSingleTap",
                  "then": "@string/template_hint_long_clickable(@string/value_single_tap)",
                  "else": "@string/template_hint_long_clickable(@string/value_double_tap)"
                }
              }
            }
          }
        }
      ]
    },
    "get_hint_for_click": {
      "fallback": [
        {
          "for_reference": "$node.actionClick",
          "evaluate": {
            "if": "$action.label",
            "then": {
              "if": "$global.inputMode == 'keyboard' && $keyCombo.hasKeyForClick",
              "then": "@string/template_custom_hint_for_actions_keyboard($keyCombo.stringRepresentationForClick, $action.label)",
              "else": {
                "if": "$global.inputMode == 'non_alphabetic_keyboard'",
                "then": "@string/template_custom_hint_for_actions(@string/value_press_select, $action.label)",
                "else": {
                    "if": "$node.role != 'text_entry_key'",
                    "then": {
                      "if": "$global.useSingleTap",
                      "then": "@string/template_custom_hint_for_actions(@string/value_single_tap, $action.label)",
                      "else": "@string/template_custom_hint_for_actions(@string/value_double_tap, $action.label)"
                    }
                }
              }
            }
          }
        },
        {
          "if": "$node.isCheckable",
          "then": {
            "if": "$global.inputMode == 'keyboard' && $keyCombo.hasKeyForClick",
            "then": "@string/template_hint_checkable_keyboard($keyCombo.stringRepresentationForClick)",
            "else": {
              "if": "$global.inputMode == 'non_alphabetic_keyboard'",
              "then": "@string/template_hint_checkable(@string/value_press_select)",
              "else": {
                "if": "$node.role != 'text_entry_key'",
                "then":{
                  "if": "$global.useSingleTap",
                  "then": "@string/template_hint_checkable(@string/value_single_tap)",
                  "else": "@string/template_hint_checkable(@string/value_double_tap)"
                }
              }
            }
          }
        },
        {
          "if": "$node.isClickable",
          "then": {
            "if": "$global.inputMode == 'keyboard' && $keyCombo.hasKeyForClick",
            "then": "@string/template_hint_clickable_keyboard($keyCombo.stringRepresentationForClick)",
            "else": {
              "if": "$global.inputMode == 'non_alphabetic_keyboard'",
              "then": "@string/template_hint_clickable(@string/value_press_select)",
              "else": {
                "if": "$node.role != 'text_entry_key'",
                "then": {
                  "if": "$global.useSingleTap",
                  "then": "@string/template_hint_clickable(@string/value_single_tap)",
                  "else": "@string/template_hint_clickable(@string/value_double_tap)"
                }
              }
            }
          }
        }
      ]
    },
    "get_custom_action_labels": {
      "join": [
        {
          "for_each_child": "$node.actions",
          "evaluate": {
            "if": "$action.isCustomAction",
            "then": "$action.label",
            "else": {
              "switch": "$action.id",
              "cases": {
                "dismiss": "@string/title_action_dismiss",
                "expand": "@string/title_action_expand",
                "collapse": "@string/title_action_collapse"
              }
            }
          }
        }
      ]
    }
  }
}
