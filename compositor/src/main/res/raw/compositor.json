{
  "events": {
    // Changes to TalkBack state.
    "SpokenFeedbackOn": {
      "ttsOutput": "@string/talkback_on",
      "ttsQueueMode": "uninterruptible",
      "ttsForceFeedback": true
    },
    "SpokenFeedbackSuspended": {
      "ttsOutput": "@string/talkback_suspended",
      "ttsQueueMode": "uninterruptible",
      "ttsForceFeedback": true
    },
    "SpokenFeedbackResumed": {
      "ttsOutput": "@string/talkback_resumed",
      "ttsQueueMode": "uninterruptible",
      "ttsForceFeedback": true
    },
    "SpokenFeedbackDisabled": {
      "ttsOutput": "@string/talkback_disabled",
      "ttsQueueMode": "uninterruptible",
      "ttsForceFeedback": true
    },
    // Changes to keyboard state.
    "CapsLockOn": {
      "ttsOutput": "@string/value_caps_lock_on",
      "ttsQueueMode": "interrupt",
      "ttsForceFeedback": true
    },
    "CapsLockOff": {
      "ttsOutput": "@string/value_caps_lock_off",
      "ttsQueueMode": "interrupt",
      "ttsForceFeedback": true
    },
    "NumLockOn": {
      "ttsOutput": "@string/value_num_lock_on",
      "ttsQueueMode": "interrupt",
      "ttsForceFeedback": true
    },
    "NumLockOff": {
      "ttsOutput": "@string/value_num_lock_off",
      "ttsQueueMode": "interrupt",
      "ttsForceFeedback": true
    },
    "ScrollLockOn": {
      "ttsOutput": "@string/value_scroll_lock_on",
      "ttsQueueMode": "interrupt",
      "ttsForceFeedback": true
    },
    "ScrollLockOff": {
      "ttsOutput": "@string/value_scroll_lock_off",
      "ttsQueueMode": "interrupt",
      "ttsForceFeedback": true
    },
    // Changes in device orientation.
    "OrientationPortrait": {
      "ttsOutput": "@string/orientation_portrait",
      "ttsQueueMode": "uninterruptible",
      "ttsForceFeedback": true
    },
    "OrientationLandscape": {
      "ttsOutput": "@string/orientation_landscape",
      "ttsQueueMode": "uninterruptible",
      "ttsForceFeedback": true
    },

    // These hint events deal with focus-event hints, not window-event hints.
    // TODO: Because the only difference between AccessFocusHint and AccessFocusHintForced
    // is FLAG_FORCED_FEEDBACK, look for a better way to do the branch.
    // TODO: Create proper output rules for hints.
    "AccessFocusHint": {
      "ttsOutput": "%get_hint_from_node",
      "ttsQueueMode": "queue"
    },
    "AccessFocusHintForced": {
      "ttsOutput": "%get_hint_from_node",
      "ttsForceFeedback": true,
      "ttsQueueMode": "queue"
    },
    "InputFocusHint": {
      "ttsOutput": "%get_focus_hint_from_node",
      "ttsForceFeedback": true,
      "ttsQueueMode": "queue"
    },
    "InputFocusHintForced": {
      "ttsOutput": "%get_focus_hint_from_node",
      "ttsQueueMode": "queue"
    },

    "ScreenMagnificationChanged": {
      "ttsOutput": {
        "if": "$screenMagnification.lastScale == 1 && $screenMagnification.currentScale > 1",
        "then": "@string/template_screen_magnification_on(round($screenMagnification.currentScale * 100))",
        "else": {
          "if": "$screenMagnification.currentScale == 1 && $screenMagnification.lastScale > 1",
          "then": "@string/screen_magnification_off",
          "else": "@string/template_screen_magnification_scale_changed(round($screenMagnification.currentScale * 100))"
        }
      },
      "ttsClearQueueGroup": "screen_magnification",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "uninterruptible",
      "ttsForceFeedback": true
    },

    // Selector events
    "EVENT_SELECT_SPEECH_RATE": {
      "ttsOutput": "@string/selector_speech_rate_output",
      "ttsForceFeedback": true
    },
    "EVENT_SELECT_VERBOSITY": {
      "ttsOutput": "@string/selector_verbosity_output",
      "ttsForceFeedback": true
    },
    "EVENT_SELECT_GRANULARITY": {
      "ttsOutput": "@string/selector_granularity_output",
      "ttsForceFeedback": true
    },
    "EVENT_SELECT_AUDIO_FOCUS": {
      "ttsOutput": "@string/selector_audio_focus_output",
      "ttsForceFeedback": true
    },
    "EVENT_SPEECH_RATE_CHANGE": {
      "ttsOutput": "@string/template_speech_rate_change(round($global.speechRate * 50))",
      "ttsForceFeedback": true
    },
    "EVENT_AUDIO_FOCUS_SWITCH": {
      "ttsOutput": {
        "if": "$global.useAudioFocus",
        "then": "@string/audio_focus_on",
        "else": "@string/audio_focus_off"
      },
      "ttsForceFeedback": true
    },

    // Accessibility Events.
    "TYPE_VIEW_ACCESSIBILITY_FOCUSED": {
      "ttsOutput": {
        "join": [
          {
            "fallback": [
              "%get_description_for_tree",
              "%event_description"
            ]
          },
          {
            "if": "#VERBOSITY_SPEAK_COLLECTION_INFO",
            "then": "%collection_item_transition"
          },
          {
            "if": "#VERBOSITY_SPEAK_COLLECTION_INFO",
            "then": "%collection_transition"
          },
          "%window_transition"
        ]
      },
      "ttsQueueMode": "flush",
      "ttsAddToHistory": true,
      "ttsForceFeedback": "!$global.syncedAccessibilityFocusLatch && $node.role != 'web_view'",
      "advanceContinuousReading": true,
      "earcon": {
        "if": "($node.windowType == 'split_screen_divider') && ($windows.lastWindowId != $node.windowId)",
        "then": "@raw/complete",
        "else": {
          "if": "$focus.isLastFocusInScrollableNode != $focus.isCurrentFocusInScrollableNode",
          "then": {
            "if": "$focus.isCurrentFocusInScrollableNode",
            "then": "@raw/chime_up",
            "else": "@raw/chime_down"
          },
          "else": {
            "if": "$node.isActionable",
            "then": "@raw/focus_actionable",
            "else": "@raw/focus"
          }
        }
      },
      "haptic": {
        "if": "$node.isActionable",
        "then": "@array/view_actionable_pattern",
        "else": "@array/view_hovered_pattern"
      },
      "preventDeviceSleep": true
    },

    "TYPE_VIEW_FOCUSED": {
      "ttsOutput": "%event_description",
      "ttsAddToHistory": true,
      // From FallbackFormatter
      // TODO: Delete porting comments.
      "earcon": {
        "if":"$event.sourceIsNull",
        "then":"@raw/focus_actionable"
      },
      "haptic": {
        "if":"$event.sourceIsNull",
        "then":"@array/view_focused_or_selected_pattern"
      }
    },

    "TYPE_VIEW_HOVER_ENTER": {
      "ttsOutput": "%event_description",
      "ttsAddToHistory": true,
      "ttsForceFeedback": true,
      // From FallbackFormatter
      "earcon": {
        "if":"$event.sourceIsNull",
        "then":"@raw/focus"
      },
      "haptic": {
        "if":"$event.sourceIsNull",
        "then":"@array/view_hovered_pattern"
      }
    },

    "TYPE_NOTIFICATION_STATE_CHANGED": {  // From speechstrategy.xml
      "ttsOutput": {
        "switch": "$event.sourceRole",
        "cases": {
          "toast": "%event_description"
        },
        "default": {
          "join": ["%event_notification_category", "$event.notificationDetails"]
        }
      },
      "ttsQueueMode": {
        "switch": "$event.sourceRole",
        "cases": {
          "toast": "uninterruptible"
        },
        "default": "queue"
      },
      "ttsAddToHistory": true,
      "ttsForceFeedback": "$node.role == 'toast'"
    },

    "TYPE_ANNOUNCEMENT": {    // From speechstrategy.xml
      "ttsOutput": "%event_description",
      "ttsQueueMode": "queue",
      "ttsAddToHistory": true,
      "ttsSkipDuplicate": true,
      "ttsForceFeedback": true,
      "haptic": "@array/notification_pattern"
    },

    "TYPE_VIEW_CLICKED": {
      "ttsOutput": {
        "fallback": [
          "%node_checked",
          "%node_descendant_checked"
        ]
      },
      "ttsAddToHistory": true,
      "ttsForceFeedback": true,
      "ttsSkipDuplicate": true,
      "refreshSourceNode": true,
      "earcon": "@raw/tick",
      "haptic": "@array/view_clicked_pattern"
    },

    "TYPE_VIEW_LONG_CLICKED": {
      "earcon": "@raw/long_clicked",
      "haptic": "@array/view_long_clicked_pattern"
    },

    // TODO: Interpret this event in WindowEventFilter.
    "TYPE_WINDOW_STATE_CHANGED": {
      "ttsOutput": {
        "switch": "$event.sourceRole",
        "cases": {
          "drawer_layout": "@string/template_drawer_opened(%event_description)",
          "icon_menu": "@string/value_options_menu_open",
          "sliding_drawer": "@string/value_sliding_drawer_opened",
          "list": {  // From speechstrategy.xml
            // TODO: Consider removing this case, since we do not see it occur.
            "if": "!$event.text0 && !$event.contentDescription",
            "then": "@plurals/template_containers($event.itemCount, %event_description, $event.itemCount)"
          }
        }
      },
      "ttsQueueMode": {
        "switch": "$event.sourceRole",
        "cases": {
          "icon_menu": "uninterruptible",
          "list": {  // From speechstrategy.xml
            "if": "!$event.text0 && !$event.contentDescription",
            "then": "uninterruptible"
          }
        }
      },
      "ttsAddToHistory": true,
      "ttsForceFeedback": true
    },

    "TYPE_WINDOW_CONTENT_CHANGED": {   // From speechstrategy.xml
      "ttsOutput": {
        "if": "$node.liveRegion != 'none'",
        "then": "%get_description_for_tree",
        "else": {
          "if": "$node.isAccessibilityFocused && $event.isContentDescriptionChanged",
          "then": "$event.contentDescription"
        }
      },
      "ttsQueueMode": {
        "if": "$node.liveRegion == 'assertive'",
        "then": "interrupt",
        "else": "queue"
      },
      // TODO: When activating AGSA with voice search button, the button
      // content description changes and TalkBack announces the change. We
      // should suppress that feedback because it will be recorded during voice
      // recognition. Current solution is to mark WINDOW_CONTENT_CHANGED
      // announcement as passive feedback, we might need to revisit this later.
      "refreshSourceNode": "$node.liveRegion != 'none'",
      "ttsAddToHistory": true,
      "ttsSkipDuplicate": true
    },

    "TYPE_VIEW_SELECTED": {
      "ttsOutput": {
        "switch": "$node.role",
        "cases": {
          "seek_control": "%rule_seek_bar",
          "progress_bar": {
            "if": "$event.sourceIsNull || $node.isFocused || $node.isAccessibilityFocused || $node.liveRegion != 'none'",
            "then": {
              "if": "length($event.text) > 0 && %event_description != $node.text",
              "then": "%event_description",
              "else": "@string/template_percent(round($event.progressPercent))"
            }
          }
        },
        "default": "%event_description"  // From speechstrategy.xml
      },
      "ttsAddToHistory": true,
      "ttsForceFeedback": "$node.role != 'seek_control'",
      "earcon": {
        "switch": "$node.role",
        "cases": {
          "seek_control": "",  // From RuleSeekBar
          "progress_bar": {  // From ProgressBarFormatter
            "if": "$event.sourceIsNull || $node.isFocused || $node.isAccessibilityFocused || $node.liveRegion != 'none'",
            "then": {
              "if": "length($event.text) > 0 && %event_description != $node.text",
              "then": "",
              "else": "@raw/scroll_tone"
            }
          }
        },
        "default": {  // From speechstrategy.xml
          "if": "!%event_description",
          "then": "@raw/focus_actionable"
        }
      },
      "earcon_rate": {
        "if": "$node.role == 'progress_bar'",
        "then": "2.0 ^ ($event.progressPercent / 50.0 - 1)"
      },
      "earcon_volume": {
        "if": "$node.role == 'progress_bar'",
        "then": "0.5"
      },
      "haptic": {
        "switch": "$node.role",
        "cases": {
          "seek_control": "",  // From RuleSeekBar
          "progress_bar": ""   // From ProgressBarFormatter
        },
        "default": {  // From speechstrategy.xml
          "if": "!%event_description",
          "then": "@array/view_focused_or_selected_pattern"
        }
      },
      "ttsQueueMode": {
        "switch": "$event.sourceRole",
        "cases": {
          "progress_bar": {
            "if": "$node.liveRegion == 'assertive'",
            "then": "interrupt",
            "else": "uninterruptible"
          },
          "action_bar_tab": "uninterruptible",  // From speechstrategy.xml
          "tab_bar": "uninterruptible",  // From speechstrategy.xml
          "seek_control": "uninterruptible"  // From RuleSeekBar
        }
      },
      "ttsClearQueueGroup": {
        "switch": "$node.role",
        "cases": {
          "progress_bar": "progress_bar",
          "seek_control": "seek_progress"
        }
      },
      "ttsSkipDuplicate": "$node.role == 'progress_bar' || $node.role == 'seek_control'"
    },

    "TYPE_VIEW_SCROLLED": {
      "earcon": "@raw/scroll_tone",
      "earcon_rate": "2.0 ^ ($event.scrollPercent / 50.0 - 1)"
    },

    "EVENT_TYPE_INPUT_TEXT_CLEAR": {
      "ttsOutput": {
        "join": [
          {
            "if": "$event.isCut",
            "then": {
              "join": [
                "@string/template_text_cut($event.beforeText)",
                "@string/value_text_cleared"
              ]
            },
            "else": "@string/value_text_cleared"
          },
          "%notify_error"
        ]
      },
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsForceFeedback": true
    },

    "EVENT_TYPE_INPUT_TEXT_REMOVE": {
      "ttsOutput": {
        "join": [
          {
            "if": "$event.isCut",
            "then": "@string/template_text_cut($event.removedText)",
            "else": "@string/template_text_removed($event.removedText)"
          },
          "%notify_error"
        ]
      },
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsPitch": 1.2,
      "ttsForceFeedback": true
    },

    "EVENT_TYPE_INPUT_TEXT_ADD": {
      "ttsOutput": {
        "join": [
          {
            "fallback": [
              "$event.initialWord",
              {
                "if": "$event.isPaste",
                "then": "@string/template_text_pasted($event.addedText)",
                "else": "$event.addedText"
              }
            ]
          },
          "%notify_max_length_reached",
          "%notify_error"
        ]
      },
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsForceFeedback": true
    },

    "EVENT_TYPE_INPUT_TEXT_REPLACE": {
      "ttsOutput": {
        "join": [
          "@string/template_text_replaced($event.addedText, $event.removedText)",
          {
            "if": "!$event.isPaste",
            "then": "spelling($event.addedText)"
          },
          "%notify_max_length_reached",
          "%notify_error"
        ]
      },
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsPitch": 1.2,
      "ttsForceFeedback": true
    },

    "EVENT_TYPE_INPUT_TEXT_PASSWORD_ADD": {
      "ttsOutput": {
        "join": [
          "@string/symbol_bullet",
          "%notify_max_length_reached",
          "%notify_error"
        ]
      },
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsForceFeedback": true
    },

    "EVENT_TYPE_INPUT_TEXT_PASSWORD_REMOVE": {
      "ttsOutput": {
        "join": [
          "@string/template_text_removed(@string/symbol_bullet)",
          "%notify_error"
        ]
      },
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsPitch": 1.2,
      "ttsForceFeedback": true
    },

    "EVENT_TYPE_INPUT_TEXT_PASSWORD_REPLACE": {
      "ttsOutput": {
        "join": [
          "@string/template_replaced_characters($event.removedCount, $event.addedCount)",
          "%notify_max_length_reached",
          "%notify_error"
        ]
      },
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsPitch": 1.2,
      "ttsForceFeedback": true
    },

    "EVENT_TYPE_INPUT_SELECTION_MOVE_CURSOR_NO_SELECTION": {
      "ttsOutput": {
        "join": [
          "$event.traversedText",
          {
            "if": "$event.toIndex == 0",
            "then": "@string/notification_type_beginning_of_field",
            "else": {
              "if": "$event.toIndex == $event.itemCount",
              "then": "@string/notification_type_end_of_field"
            }
          }
        ]
      },
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsForceFeedback": true
    },

    "EVENT_TYPE_INPUT_SELECTION_MOVE_CURSOR_WITH_SELECTION": {
      "ttsOutput": {
        "join": [
          {
            "if": "$event.deselectedText",
            "then": "@string/template_text_unselected($event.deselectedText)"
          },
          {
            "if": "$event.selectedText",
            "then": "@string/template_text_selected($event.selectedText)"
          }
        ]
      },
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsForceFeedback": true
    },

    "EVENT_TYPE_INPUT_SELECTION_MOVE_CURSOR_SELECTION_CLEARED": {
      "ttsOutput": {
        "join": [
          "@string/notification_type_selection_cleared",
          {
            "if": "$event.toIndex == 0",
            "then": "@string/notification_type_beginning_of_field",
            "else": {
              "if": "$event.toIndex == $event.itemCount",
              "then": "@string/notification_type_end_of_field"
            }
          }
        ]
      },
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsForceFeedback": true
    },

    "EVENT_TYPE_INPUT_SELECTION_TEXT_TRAVERSAL": {
      // TODO: Make this the same as EVENT_TYPE_INPUT_SELECTION_MOVE_CURSOR_NO_SELECTION ?
      "ttsOutput": "$event.traversedText",
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsForceFeedback":true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsForceFeedback": true
    },

    "EVENT_TYPE_INPUT_SELECTION_SELECT_ALL_WITH_KEYBOARD": {
      "ttsOutput": "@string/template_announce_selected_text($event.textOrDescription)",
      "ttsAddToHistory": true,
      "ttsClearQueueGroup": "text_selection",
      "ttsInterruptSameGroup": true,
      "ttsQueueMode": "interruptible_if_long",
      "ttsForceFeedback": true
    },

    // Text events with no speech feedback
    "EVENT_TYPE_INPUT_CHANGE_INVALID": {},
    "EVENT_TYPE_INPUT_SELECTION_FOCUS_EDIT_TEXT": {},
    "EVENT_TYPE_INPUT_SELECTION_MOVE_CURSOR_TO_BEGINNING": {},  // Feedback handled by menurules.
    "EVENT_TYPE_INPUT_SELECTION_MOVE_CURSOR_TO_END": {},
    "EVENT_TYPE_INPUT_SELECTION_CUT": {},  // Feedback handled by EVENT_TYPE_INPUT_TEXT_ADD/REMOVE
    "EVENT_TYPE_INPUT_SELECTION_PASTE": {},
    "EVENT_TYPE_INPUT_SELECTION_RESET_SELECTION": {},
    "EVENT_TYPE_INPUT_SELECTION_SELECT_ALL": {}  // Feedback handled by menurules.RuleEditText
  },

  "named_nodes": {
    // Events
    "event_description": {
      "fallback": [
        "$event.contentDescription",
        "%event_aggregate_text"
      ]
    },
    "event_notification_category": {
      "switch": "$event.notificationCategory",
      "cases": {
        "call": "@string/notification_category_call",
        "msg": "@string/notification_category_msg",
        "email": "@string/notification_category_email",
        "event": "@string/notification_category_event",
        "promo": "@string/notification_category_promo",
        "alarm": "@string/notification_category_alarm",
        "progress": "@string/notification_category_progress",
        "social": "@string/notification_category_social",
        "err": "@string/notification_category_err",
        "transport": "@string/notification_category_transport",
        "sys": "@string/notification_category_sys",
        "service": "@string/notification_category_service"
      }
    },
    "event_aggregate_text": {
      "join": "$event.text"
    },
    "notify_error": {  // TextFormatters.ChangedTextFormatter.notifyError()
      "if": "$event.sourceError",
      "then": "@string/template_text_error($event.sourceError)"
    },
    "notify_max_length_reached": {  // TextFormatters.ChangedTextFormatter.notifyMaxLengthReached()
      "if": "$event.sourceMaxTextLength > -1 && length($event.text0) >= $event.sourceMaxTextLength",
      "then": "@string/value_text_max_length"
    },

    // Collections
    "collection_item_transition": {
      "if": "$collection.isRowTransition || $collection.isColumnTransition",
      "then": {
        "switch": "$collection.role",
        "cases": {
          "grid": {
            "join": [{
              "if": "!$node.roleDescription",
              "then": {
                "switch": "$collection.tableItem.headingType",
                "cases": {
                  "column": "@string/column_heading_template",
                  "row": "@string/row_heading_template,",
                  "indeterminate": "@string/heading_template"
                }
              }
            }, {
              "if": "$collection.isRowTransition && $collection.tableItem.rowIndex != -1 && $collection.tableItem.headingType != 'row'",
              "then": {
                "fallback": [
                  "$collection.tableItem.rowName",
                  "@string/row_index_template($collection.tableItem.rowIndex + 1)"
                ]
              }
            }, {
              "if": "$collection.isColumnTransition && $collection.tableItem.columnIndex != -1 && $collection.tableItem.headingType != 'column'",
              "then": {
                "fallback": [
                  "$collection.tableItem.columnName",
                  "@string/column_index_template($collection.tableItem.columnIndex + 1)"
                ]
              }
            }]
          }
        },
        "default": {
          "if": "$collection.listItem.isHeading && !$node.roleDescription",
          "then": "@string/heading_template"
        }
      }
    },
    "collection_transition": {
      "switch": "$collection.transition",
      "cases": {
        "none": "",
        "enter": {
          "switch": "$collection.role",
          "cases": {
            "list": {
              "join": [{
                  "if": "$collection.name",
                  "then": "@string/in_list($collection.name)",
                  "else": "@string/in_list_without_name"
                },
                "%collection_level",
                "%collection_list_item_count"
              ]
            },
            "grid": {
              "join": [{
                "if": "$collection.name",
                "then": "@string/in_grid($collection.name)",
                "else": "@string/in_grid_without_name"
              },
                "%collection_level",
                "%collection_grid_item_count"
              ]
            }
          }
        },
        "exit": {
          "if": "$collection.exists",
          "then": {
            "switch": "$collection.role",
            "cases": {
              "list": {
                "if": "$collection.name",
                "then": "@string/out_of_list($collection.name)",
                "else": "@string/out_of_list_without_name"
              },
              "grid": {
                "if": "$collection.name",
                "then": "@string/out_of_grid($collection.name)",
                "else": "@string/out_of_grid_without_name"
              }
            }
          }
        },
        "interior": ""
      }
    },
    "collection_level": {
      "if": "$collection.level >= 0",
      "then": "@string/template_collection_level($collection.level + 1)"
    },
    "collection_list_item_count": {
      "if": "$collection.isVerticalAligned && $collection.rowCount >= 0",
      "then": "@plurals/template_list_total_count($collection.rowCount, $collection.rowCount)",
      "else": {
        "if": "$collection.isHorizontalAligned && $collection.columnCount >= 0",
        "then": "@plurals/template_list_total_count($collection.columnCount, $collection.columnCount)"
      }
    },
    "collection_grid_item_count": {
      "if": "$collection.rowCount >= 0 && $collection.columnCount >= 0",
      "then": "@plurals/template_list_row_count($collection.rowCount, $collection.rowCount), @plurals/template_list_column_count($collection.columnCount, $collection.columnCount)"
    },
    // Windows
    "window_transition": {
      "if": "$node.windowId != $windows.lastWindowId",
      "then": {
        "if": "$node.windowType == 'picture_in_picture'",
        "then": "@string/template_overlay_window(getWindowTitle($node.windowId))",
        "else": {
          "if": "($windows.isSplitScreenMode || $global.inputMode == 'keyboard') && ($node.windowType == 'application' || $node.windowType == 'system')",
          "then": "getWindowTitle($node.windowId)"
        }
      }
    },

    // Nodes
    // From NodeSpeechRuleProcessor.getDescriptionForTree()
    "get_description_for_tree": {
      "switch": "#VERBOSITY_DESCRIPTION_ORDER",
      "cases": {
        "StateNameRolePosition": {
          "join": [
            "%notify_selected",
            "%tree_description_with_label",
            "%notify_disabled" // Announcement of "disabled" should always be a postfix.
          ]
        },
        "RoleNameStatePosition": {
          "join": [
            "%tree_description_with_label",
            "%notify_selected",
            "%notify_disabled"
          ]
        },
        "NameRoleStatePosition": {
          "join": [
            "%tree_description_with_label",
            "%notify_selected",
            "%notify_disabled"
          ]
        }
      }
    },

    // From NodeSpeechRuleProcessor.formatTextWithLabel()
    "tree_description_with_label": {
      "if": "length(%label_description) > 0",
      "then": "@string/template_labeled_item(%append_description_for_tree, %label_description)",
      "else": "%append_description_for_tree"
    },

    "notify_disabled": {
      "if": "$node.isActionable && !$node.isEnabled",
      "then": "@string/value_disabled"
    },

    "notify_selected": {
      "if": "$node.isSelected",
      "then": "@string/value_selected"
    },

    // From NodeSpeechRuleProcessor.formatTextWithLabel()
    "label_description": {
      "for_reference": "$node.labeledBy",
      "evaluate": "%append_description_for_tree"
    },

    // From NodeSpeechRuleProccessor.appendDescriptionForTree()
    "append_description_for_tree": {
      "join":[
        {
          "switch": "#VERBOSITY_DESCRIPTION_ORDER",
          "cases": {
            "StateNameRolePosition": "conditionalPrepend(%description_for_tree_status, %description_for_tree_nodes)",
            "RoleNameStatePosition": "conditionalAppend(%description_for_tree_nodes, %description_for_tree_status)",
            "NameRoleStatePosition": "conditionalAppend(%description_for_tree_nodes, %description_for_tree_status)"
          }
        },
        // TODO: Currently we have appended the accessibility hint just after the node details that talkback announces.
        // In futire we can append $node.hint for a node similar to name, state and type and take hint into consideration for deciding VERBOSITY_DESCRIPTION_ORDER.
        // These hints are only present for edit_texts and web view at present.
        "%get_accessibility_node_hint"
      ]
    },

    "description_for_tree_status": {
      "join": [
        // From NodeSpeechRuleProcessor.appendExpandedOrCollapsedStatus()
        {
          "if": "$node.isExpandable",
          "then": "@string/value_collapsed"
        },
        {
          "if": "$node.isCollapsible",
          "then": "@string/value_expanded"
        },
        // From NodeSpeechRuleProcessor.appendCheckedStatus()
        {
          "if": "$node.isCheckable && $node.role != 'switch' && $node.role != 'toggle_button' && ($node.role != 'checked_text_view' || $node.isChecked)",
          "then": {
            "if": "$node.isChecked",
            "then": "@string/value_checked",
            "else": "@string/value_not_checked"
          }
        }
      ]
    },

    "description_for_tree_nodes": {
      "join": [
        "%get_description_for_node",
        {
          "if": "($node.role == 'grid' || $node.role == 'list' || $node.role == 'pager' || !$node.contentDescription) && $node.role != 'web_view'",
          "then": {
            // Recurse on all visible & un-focusable children, ascending.
            "join": [
              {
                "for_each_child": "$node.childrenAscending",
                "evaluate": {
                  "if": "$node.isVisible && !$node.isAccessibilityFocusable",
                  "then": "%append_description_for_tree"
                }
              }
            ]
          }
        }
      ]
    },

    // From NodeSpeechRuleProcessor.getDescriptionForNode()
    "get_description_for_node": {
      "switch": "$node.role",
      "cases": {
        "drop_down_list": "%rule_default", //RuleSimpleHintTemplate. Falls down to RuleDefault.
        "switch": "%rule_switch",
        "toggle_button": "%rule_switch",
        "image":"%rule_non_text_views",
        "image_button": "%rule_non_text_views",
        "edit_text": "%rule_edit_text",
        "seek_control": "%rule_seek_bar",
        "pager": "%rule_default" // RulePager. Falls down to RuleDefault
      },
      "default": {
        // From RulePagerPage
        "if": {
          "for_reference": "$node.parent",
          "evaluate": "$node.role == 'pager' && $node.visibleChildCount == 1"
        },
        "then": "%rule_pager_page",
        "else": {
          // From RuleViewGroup
          "if": "$node.role == 'view_group'",
          "then": "%rule_view_group",
          "else": "%rule_default"   // From NodeSpeechRuleProcessor
        }
      }
    },
    "get_node_text": {  // AccessibilityNodeInfoUtils.getNodeText()
      "fallback": [
        {
          // If focusing on-screen keyboard key... apply speak-passwords policy to hide key name.
          "if": "$event.sourceIsKeyboard && $global.lastTextEditIsPassword && !$global.speakPasswordOnAndroidShowingPasswords",
          "then": "@string/symbol_bullet",
          "else": "$node.contentDescription"
        },
        "$node.text"
      ]
    },
    "get_role_description_or_default": {
      "fallback": [
        "$node.roleDescription",
        "%node_role"
      ]
    },
    "node_role": {
      "switch": "$node.role",
      "cases": {
        "button": "@string/value_button",
        "check_box": "@string/value_checkbox",
        "drop_down_list": "@string/value_spinner",
        "edit_text": "@string/value_edit_box",
        "grid": "@string/value_gridview",
        "image": "@string/value_image",
        "image_button": "@string/value_button", // Same as |button|
        "list": "@string/value_listview",
        "pager": "@string/value_pager",
        "progress_bar": "@string/value_progress_bar",
        "radio_button": "@string/value_radio_button",
        "seek_control": "@string/value_seek_bar",
        "switch": "@string/value_switch",
        "tab_bar": "@string/value_tabwidget",
        "toggle_button": "@string/value_switch", // Same as |switch|
        "view_group": "", // None
        "web_view": "@string/value_webview",
        "checked_text_view": "" // None
      }
    },
    "node_text_and_role": {
      "join": [
        "%get_node_text",
        "%get_role_description_or_default"
      ]
    },
    "role_and_node_text": {
      "join": [
        "%get_role_description_or_default",
        "%get_node_text"
      ]
    },
    "node_descendant_checked": {
      // Either node is checkable, or recurse on descendants.
      "fallback": [
        "%node_checked",
        {
          "join": [
            {
              "for_each_child": "$node.children",
              "evaluate": "%node_descendant_checked"
            }
          ]
        }
      ]
    },

    "node_checked": {
      // If node is checkable, speak checked state depending on node type.
      "if": "$node.isCheckable",
      "then": {
        "switch": "$node.role",
        "cases": {
          "switch": {
            "if": "$node.isChecked",
            "then": "@string/value_on",
            "else": "@string/value_off"
          },
          "toggle_button": {
            "if": "$node.isChecked",
            "then": "@string/value_on",
            "else": "@string/value_off"
          }
        },
        "default": {
          "if": "$node.isChecked",
          "then": "@string/value_checked",
          "else": "@string/value_not_checked"
        }
      }
    },

    "node_text_or_event_aggregate_text": {
      "fallback": [
        "$node.text",
        "%event_aggregate_text"
      ]
    },

    "node_text_or_label": {
      "fallback": [
        "%get_node_text",
        "$node.labelText",
        {
          "if": "#VERBOSITY_SPEAK_ELEMENT_IDS",
          "then": "$node.viewIdText"
        }
      ]
    },

    // SpeechRules
    "rule_default": {
      "if": "!#VERBOSITY_SPEAK_ROLE",
      "then": "%get_node_text",
      "else": {
        "switch": "#VERBOSITY_DESCRIPTION_ORDER",
        "cases": {
          "RoleNameStatePosition": "%role_and_node_text",
          "StateNameRolePosition": "%node_text_and_role",
          "NameRoleStatePosition": "%node_text_and_role"
        }
      }
    },

    "rule_edit_text": {
      "switch": "#VERBOSITY_DESCRIPTION_ORDER",
      "cases": {
        "RoleNameStatePosition": {
          "join": [
            {
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_role_description_or_default"
            },
            "%get_edit_text_text",
            "%get_edit_text_state"
          ]
        },
        "StateNameRolePosition": {
          "join": [
            "%get_edit_text_state",
            "%get_edit_text_text",
            {
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_role_description_or_default"
            }
          ]
        },
        "NameRoleStatePosition": {
          "join": [
            "%get_edit_text_text",
            {
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_role_description_or_default"
            },
            "%get_edit_text_state"
          ]
        }
      }
    },

    "rule_pager_page": {
      "if": "!#VERBOSITY_SPEAK_ROLE",
      "then": "%get_node_text",
      "else": {
        "switch": "#VERBOSITY_DESCRIPTION_ORDER",
        "cases": {
          "RoleNameStatePosition": {
            "join": [
              "%get_pager_page_role_description",
              "%get_node_text"
            ]
          },
          "StateNameRolePosition": {
            "join": [
              "%get_node_text",
              "%get_pager_page_role_description"
            ]
          },
          "NameRoleStatePosition": {
            "join": [
              "%get_node_text",
              "%get_pager_page_role_description"
            ]
          }
        }
      }
    },

    "rule_switch": {
      "switch": "#VERBOSITY_DESCRIPTION_ORDER",
      "cases": {
        "RoleNameStatePosition": {
          "join": [
            {
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_role_description_or_default"
            },
            "$node.contentDescription", // Name
            "%get_switch_state"
          ]
        },
        "StateNameRolePosition": {
          "join": [
            "%get_switch_state",
            "$node.contentDescription", // Name
            {
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_role_description_or_default"
            }
          ]
        },
        "NameRoleStatePosition": {
          "join": [
            "$node.contentDescription", // Name
            {
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_role_description_or_default"
            },
            "%get_switch_state"
          ]
        }
      }
    },

    "rule_seek_bar": { // TODO: Investigate if we should announce role description for TYPE_VIEW_SELECTED event.
      "if": "$node.isAccessibilityFocused",
      "then": {
        "switch": "#VERBOSITY_DESCRIPTION_ORDER",
        "cases": {
          "RoleNameStatePosition": {
            "join": [
              {
                "if": "#VERBOSITY_SPEAK_ROLE",
                "then": "%get_role_description_or_default"
              },
              "%get_node_text",
              "%get_seek_bar_state"
            ]
          },
          "StateNameRolePosition": {
            "join": [
              "%get_seek_bar_state",
              "%get_node_text",
              {
                "if": "#VERBOSITY_SPEAK_ROLE",
                "then": "%get_role_description_or_default"
              }
            ]
          },
          "NameRoleStatePosition": {
            "join": [
              "%get_node_text",
              {
                "if": "#VERBOSITY_SPEAK_ROLE",
                "then": "%get_role_description_or_default"
              },
              "%get_seek_bar_state"
            ]
          }
        }
      }
    },

    "rule_non_text_views": {
      "switch": "#VERBOSITY_DESCRIPTION_ORDER",
      "cases": {
        "RoleNameStatePosition": {
          "join": [
            { // Role
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_non_text_view_role"
            },
            "%node_text_or_label", // Name
            { // State
              "if": "!%node_text_or_label",
              "then": "@string/value_unlabelled"
            }
          ]
        },
        "StateNameRolePosition": {
          "join": [
            { // State
              "if": "!%node_text_or_label",
              "then": "@string/value_unlabelled"
            },
            "%node_text_or_label", // Name
            { // Role
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_non_text_view_role"
            }
          ]
        },
        "NameRoleStatePosition": {
          "join": [
            "%node_text_or_label", // Name
            { // ROle
              "if": "#VERBOSITY_SPEAK_ROLE",
              "then": "%get_non_text_view_role"
            },
            { // State
              "if": "!%node_text_or_label",
              "then": "@string/value_unlabelled"
            }
          ]
        }
      }
    },

    "rule_view_group": "%get_node_text",


    // Utils for speech rules.
    "get_edit_text_state": {
      "join": [
        {
          "if": "$node.isFocused && (!$global.hasWindowSupport || $global.isKeyboardActive)", // isCurrentlyEditing
          "then": "@string/value_edit_box_editing"
        },
        {
          "if": "$global.isSelectionModeActive",
          "then": "@string/notification_type_selection_mode_on"
        }
      ]
    },

    "get_edit_text_text": {
      "fallback": [
        {
          "if": "!$node.isPassword || $global.speakPasswordOnAllAndroid",
          "then": "$node.text"
        },
        {
          "join": [
            {
              "fallback": [
                "$node.contentDescription",
                {
                  "if": "$node.isPassword && !$global.speakPasswordOnAllAndroid",
                  "then": "@string/value_password"
                }
              ]
            },
            {
              "if": "$node.isPassword && !$global.speakPasswordOnAllAndroid && $node.text",
              "then": {
                "if": "$node.supportsActionSetSelection", // !isEmptyEditTextWithHint()
                "then": "@plurals/template_password_character_count(length($node.text), length($node.text))",
                "else": "$node.text"
              }
            }
          ]
        }
      ]
    },

    "get_pager_page_role_description": {
       "fallback": [
          "$node.roleDescription",
          "@string/value_pager_page"
        ]
     },

    "get_seek_bar_state": {
      "if": "$event.itemCount > 0",
      "then": "@string/template_percent(100 * $event.currentItemIndex / $event.itemCount)" // TODO: Check if we can reuse $event.progressPercent.
    },

    "get_non_text_view_role": {
      "fallback": [
        "$node.roleDescription",
        {
          "if": "!($node.role == 'image' && $node.supportsActionSelect)",
          "then": "%node_role"
        }
      ]
    },

    "get_switch_state": {
      "join": [
        "%node_text_or_event_aggregate_text", // Text of switch widget is "on"/"off" state.
        { // Complementary state for toggle button and when there is no state information from text.
          "if": "$node.role == 'toggle_button' || !%node_text_or_event_aggregate_text",
          "then": {
            "if": "$node.isChecked",
            "then": "@string/value_checked",
            "else": "@string/value_not_checked"
          }
        }
      ]
    },

    // HintRules

    // ProcessorAccessibilityHints.getHintFromNode()
    // RuleSimpleHintTemplate(dropdown list), RuleEditText, RuleSeekBar and RulePager have special implementation of hints, other rules fall down to RuleDefault.
    "get_hint_from_node": {
      "if": "$node.isEnabled",
      "then": {
        "switch": "$node.role",
        "cases": {
          "drop_down_list": "%hint_rule_drop_down_list",
          "edit_text": "%hint_rule_edit_text",
          "seek_control": "%hint_rule_seek_bar",
          "pager": "%hint_rule_pager"
        },
        "default": "%hint_rule_default"
      }
    },

    // Hint when focusing password-input field: use headphones to hear password.
    "get_focus_hint_from_node": {
      "if": "$node.isEnabled",
      "then": {
        "switch": "$node.role",
        "cases": {
          "edit_text": {
            "if": "$node.isPassword && !$global.speakPasswordOnAndroidShowingPasswords",
            "then": "@string/summaryOff_pref_speak_passwords_without_headphones"
          }
        }
      }
    },

    "get_accessibility_node_hint": {
      // append hint to edit_text only if the edit_text is not already showing the hint as its text (when the edit_text is blank).
      "if": "$node.role != 'edit_text' || !$node.isShowingHint",
      "then": "$node.hint"
    },

    // Instance of RuleSimpleHintTemplate
    "hint_rule_drop_down_list": {
      // get_custom_hint_for_click
      "if": "$global.inputMode == 'keyboard' && $keyCombo.hasKeyForClick",
      "then": "@string/template_hint_spinner_keyboard($keyCombo.stringRepresentationForClick)",
      "else": {
        "if": "$global.inputMode == 'non_alphabetic_keyboard'",
        "then": "@string/template_hint_spinner(@string/value_press_select)",
        "else": {
          "if": "$global.useSingleTap",
          "then": "@string/template_hint_spinner(@string/value_single_tap)",
          "else": "@string/template_hint_spinner(@string/value_double_tap)"
        }
      }
    },

    "hint_rule_edit_text": {
      "join": [
        "%get_hint_for_custom_actions",
        "%get_hint_for_actions",
        {
          "if": "!$node.isFocused",
          "then": {
            // get_custom_hint_for_click
            "if": "$global.inputMode == 'keyboard' && $keyCombo.hasKeyForClick",
            "then": "@string/template_hint_edit_text_keyboard($keyCombo.stringRepresentationForClick)",
            "else": {
              "if": "$global.inputMode == 'non_alphabetic_keyboard'",
              "then": "@string/template_hint_edit_text(@string/value_press_select)",
              "else": {
                "if": "$global.useSingleTap",
                "then": "@string/template_hint_edit_text(@string/value_single_tap)",
                "else": "@string/template_hint_edit_text(@string/value_double_tap)"
              }
            }
          }
        },
        "%get_hint_for_long_click"
      ]
    },

    "hint_rule_seek_bar": {
      "if": "$node.supportsActionScrollForward || $node.supportsActionScrollBackward",
      "then": "@string/template_hint_seek_control",
      "else": "%hint_rule_default"
    },

    "hint_rule_pager": {
      "if": "$node.supportsActionScrollForward || $node.supportsActionScrollBackward",
      "then": "@string/template_hint_pager",
      "else": "@string/template_hint_pager_single_page"
    },

    "hint_rule_default": {
      "join": [
        "%get_hint_for_custom_actions",
        "%get_hint_for_actions",
        "%get_hint_for_click",
        "%get_hint_for_long_click"
      ]
    },

    // Utils.
    "get_hint_for_custom_actions": "conditionalPrependWithSpaceSeparator(@string/template_hint_custom_actions, %get_custom_action_labels)",

    "get_hint_for_actions": {
      "join": [
        {
          "for_each_child": "$node.actions",
          "evaluate": {
            "if": "!$action.isClick && !$action.isLongClick && !$action.label && !$action.isCustomAction",
            "then": "$action.label"
          }
        }
      ]
    },

    "get_hint_for_long_click": {
      "fallback": [
        {
          "for_reference": "$node.actionLongClick",
          "evaluate": {
            "if": "$action.label",
            "then": {
              "if": "$global.inputMode == 'keyboard' && $keyCombo.hasKeyForLongClick",
              "then": "@string/template_custom_hint_for_actions_keyboard($keyCombo.stringRepresentationForLongClick, $action.label)",
              "else": {
                "if": "$global.inputMode == 'non_alphabetic_keyboard'",
                "then": "@string/template_custom_hint_for_long_clickable_actions(@string/value_press_select, $action.label)",
                "else": {
                  "if": "$global.useSingleTap",
                  "then": "@string/template_custom_hint_for_long_clickable_actions(@string/value_single_tap, $action.label)",
                  "else": "@string/template_custom_hint_for_long_clickable_actions(@string/value_double_tap, $action.label)"
                }
              }
            }
          }
        },
        {
          "if": "$node.isLongClickable",
          "then": {
            "if": "$global.inputMode == 'keyboard' && $keyCombo.hasKeyForLongClick",
            "then": "@string/template_hint_long_clickable_keyboard($keyCombo.stringRepresentationForLongClick)",
            "else": {
              "if": "$global.inputMode == 'non_alphabetic_keyboard'",
              "then": "@string/template_hint_long_clickable(@string/value_press_select)",
              "else": {
                "if": "$global.useSingleTap",
                "then": "@string/template_hint_long_clickable(@string/value_single_tap)",
                "else": "@string/template_hint_long_clickable(@string/value_double_tap)"
              }
            }
          }
        }
      ]
    },

    "get_hint_for_click": {
      "fallback": [
        {
          "for_reference": "$node.actionClick",
          "evaluate": {
            "if": "$action.label",
            "then": {
              "if": "$global.inputMode == 'keyboard' && $keyCombo.hasKeyForClick",
              "then": "@string/template_custom_hint_for_actions_keyboard($keyCombo.stringRepresentationForClick, $action.label)",
              "else": {
                "if": "$global.inputMode == 'non_alphabetic_keyboard'",
                "then": "@string/template_custom_hint_for_actions(@string/value_press_select, $action.label)",
                "else": {
                  "if": "$global.useSingleTap",
                  "then": "@string/template_custom_hint_for_actions(@string/value_single_tap, $action.label)",
                  "else": "@string/template_custom_hint_for_actions(@string/value_double_tap, $action.label)"
                }
              }
            }
          }
        },
        {
          "if": "$node.isCheckable",
          "then": {
            "if": "$global.inputMode == 'keyboard' && $keyCombo.hasKeyForClick",
            "then": "@string/template_hint_checkable_keyboard($keyCombo.stringRepresentationForClick)",
            "else": {
              "if": "$global.inputMode == 'non_alphabetic_keyboard'",
              "then": "@string/template_hint_checkable(@string/value_press_select)",
              "else": {
                "if": "$global.useSingleTap",
                "then": "@string/template_hint_checkable(@string/value_single_tap)",
                "else": "@string/template_hint_checkable(@string/value_double_tap)"
              }
            }
          }
        },
        {
          "if": "$node.isClickable",
          "then": {
            "if": "$global.inputMode == 'keyboard' && $keyCombo.hasKeyForClick",
            "then": "@string/template_hint_clickable_keyboard($keyCombo.stringRepresentationForClick)",
            "else": {
              "if": "$global.inputMode == 'non_alphabetic_keyboard'",
              "then": "@string/template_hint_clickable(@string/value_press_select)",
              "else": {
                "if": "$global.useSingleTap",
                "then": "@string/template_hint_clickable(@string/value_single_tap)",
                "else": "@string/template_hint_clickable(@string/value_double_tap)"
              }
            }
          }
        }
      ]
    },

    "get_custom_action_labels": {
      "join": [
        {
          "for_each_child": "$node.actions",
          "evaluate": {
            "if": "$action.isCustomAction",
            "then": "$action.label",
            "else": {
              "switch": "$action.id",
              "cases": {
                "dismiss": "@string/title_action_dismiss",
                "expand": "@string/title_action_expand",
                "collapse": "@string/title_action_collapse"
              }
            }
          }
        }
      ]
    }
  }
}
